@{
    ViewData["Title"] = "Middleware";
}

<div class="text-center">
    <h1 class="display-4">Middleware - П3 проміжного рівня</h1>
</div>

<p>
    Сесії дозволяють зберігати дані між різними запитами і, як наслідок,
    утримувати автентифікацію користувача. Але процес перевірки стану сесії (наявність
    збережених даних) має відбуватись у кожному методі кожного контролера.
    Виникає потреба якогось універсального обʼєкта, який би виконував активність
    для усіх запитів - усіх контролерів.
</p>
<p>
    Концепція Middleware - утворення "шаруватої" архітектури програми, за якої
    запит, що надходить, проходить усі Middleware шар за шаром. Більш того,
    відповідь (response) проходить ці шари, але у зворотному порядку.
</p>
<p>
    3 точки зору програмування, Middleware це класи (обʼєкти), які вбудовуються
    у "ланцюг" послідовного виклику у "проміжному рівні", який передує запуску
    контроллерів. Ланцюг одномірний, послідовний, отже порядок Middleware має
    значення.
</p>

<p>
    Створення Middleware
</p>

<ul>
    <li>Створюємо папку Middleware у проєкті (одноразово)</li>
    <li>
        Створюємо клас, у ньому необхідно оголосити посилання на наступне Middleware
        та створити метод InvokeAsync / Invoke
    </li>
    <li>
        Метод InvokeAsync / Invoke має викликати наступну ланку, інакше
        оброблення запиту припиниться
        </li>
    <li>
        Оскільки конструктор Middleware зарезервований системою, інжекція залежностей здійснюється через метод InvokeAsync / Invoke
        </li>
    <li>Включення Middleware традиційно робиться у Program.cs методами UseXxxx() </li>
    <li></li>
</ul>